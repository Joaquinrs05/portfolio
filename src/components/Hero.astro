---

---

<section class="hero">
  <div class="container">
    <div class="hero-card">
      <div class="hero-content">
        <p class="hero-chip">
          <span class="type-line" data-type-line data-type-speed="18">~/builds/portfolio</span>
          <span class="blink">▹</span>
        </p>
        <h1 class="type-line" data-type-line data-type-speed="15">Joaquín Rodriguez</h1>
        <p class="type-line" data-type-line data-type-speed="22">
          Frontend engineer que mezcla diseño funcional con obsesión por el código limpio. Me gusta convertir ideas complejas en productos que se sienten rápidos, accesibles y con personalidad.
        </p>

        <div class="hero-tags">
          <span>TypeScript</span>
          <span>Astro</span>
          <span>Angular</span>
          <span>N8N Automatization</span>
          <span>UX Engineering</span>
        </div>

        <div class="hero-meta">
          <div>
            <span class="label">Focus actual</span>
            <strong>Webs Atractivas visualmente</strong>
          </div>
          <div>
            <span class="label">Status</span>
            <strong>Disponible para colaborar</strong>
          </div>
        </div>
      </div>

      <div class="hero-divider"></div>

      <div class="hero-terminal">
        <div class="terminal">
          <div class="terminal-header">
            <span class="led red"></span>
            <span class="led yellow"></span>
            <span class="led green"></span>
            <span class="terminal-title">devshell — zsh</span>
          </div>
          <div class="terminal-body">
            <pre><code>const joaquin = &#123;
  role: "Frontend Engineer",
  stack: ["Astro", "React", "GLSL", "Node"],
  values: ["detalle", "performance", "DX"],
  currentlyBuilding: "interfaces que se sienten vivas",
&#125;;

deploy(joaquin)
  .with("ideas claras")
  .and("código honesto");</code></pre>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<style>
  .hero {
    min-height: 100vh;
    display: flex;
    align-items: center;
    padding: clamp(3rem, 8vw, 6rem) 0;
    position: relative;
    overflow: hidden;
    opacity: 0;
    animation: fadeInUp 1s ease forwards;
  }
  .hero::before,
  .hero::after {
    display: none;
  }

  .hero-grid {
    display: grid;
    gap: clamp(2rem, 4vw, 4rem);
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    position: relative;
    z-index: 1;
  }

  .hero-card {
    max-width: 700px;
    margin: 0 auto;
    padding: clamp(2rem, 3vw, 3.5rem);
    border-radius: 28px;
    background: rgba(10, 10, 10, 0.7);
    border: 1px solid rgba(94, 234, 212, 0.25);
    backdrop-filter: blur(20px);
    box-shadow: 0 30px 70px rgba(0, 0, 0, 0.5);
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
  }

  .hero-content {
    width: 100%;
  }

  .hero-divider {
    height: 1px;
    background: rgba(94, 234, 212, 0.15);
    margin: clamp(1.5rem, 3vw, 2.5rem) 0;
  }

  .hero-terminal {
    width: 100%;
  }

  .hero-copy,
  .hero-panel {
    padding: clamp(2rem, 3vw, 3.5rem);
    border-radius: 28px;
    background: rgba(10, 10, 10, 0.7);
    border: 1px solid rgba(94, 234, 212, 0.25);
    backdrop-filter: blur(20px);
    box-shadow: 0 30px 70px rgba(0, 0, 0, 0.5);
  }

  .hero-chip {
    font-family: "IBM Plex Mono", "Fira Code", monospace;
    letter-spacing: 0.08em;
    font-size: 0.85rem;
    color: var(--accent);
    margin-bottom: 1.25rem;
    display: inline-flex;
    align-items: center;
    gap: 0.4rem;
  }

  .blink {
    animation: blink 1.2s steps(2) infinite;
  }

  .hero-content h1 {
    font-size: clamp(2.8rem, 6vw, 4.8rem);
    margin-bottom: 1rem;
    background: linear-gradient(120deg, var(--text-primary), var(--accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .hero-content p {
    font-size: clamp(1.1rem, 2vw, 1.4rem);
    color: var(--text-secondary);
    line-height: 1.8;
    margin-bottom: 1.75rem;
    max-width: 600px;
    word-spacing: 0.1em;
  }

  .hero-content .hero-tags,
  .hero-content .hero-meta {
    opacity: 0;
    transform: translateY(12px);
    transition: opacity 0.6s ease, transform 0.6s ease;
  }

  .hero-content.ready .hero-tags,
  .hero-content.ready .hero-meta {
    opacity: 1;
    transform: translateY(0);
  }

  .hero-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    margin-bottom: 2rem;
  }

  .hero-tags span {
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    padding: 0.45rem 0.9rem;
    border-radius: 999px;
    background: rgba(59, 130, 246, 0.15);
    border: 1px solid rgba(59, 130, 246, 0.35);
  }

  .hero-meta {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 1rem;
  }

  .hero-meta strong,
  .panel-footer strong {
    display: block;
    margin-top: 0.35rem;
    font-size: 1rem;
    color: var(--text-primary);
  }

  .hero-panel {
    display: flex;
    flex-direction: column;
    gap: 0;
  }

  .terminal {
    background: rgba(17, 24, 39, 0.9);
    border-radius: 22px;
    border: 1px solid rgba(148, 163, 184, 0.2);
    overflow: hidden;
  }

  .terminal-header {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.75rem 1.25rem;
    background: rgba(15, 23, 42, 0.95);
    border-bottom: 1px solid rgba(148, 163, 184, 0.15);
    font-family: "IBM Plex Mono", "Fira Code", monospace;
    font-size: 0.9rem;
    color: rgba(226, 232, 240, 0.7);
  }

  .terminal-title {
    margin-left: auto;
  }

  .led {
    width: 0.75rem;
    height: 0.75rem;
    border-radius: 50%;
    display: inline-block;
  }

  .led.red {
    background: #ef4444;
  }

  .led.yellow {
    background: #fbbf24;
  }

  .led.green {
    background: #22c55e;
  }

  .terminal-body {
    padding: 1.75rem;
    font-family: "IBM Plex Mono", "Fira Code", monospace;
    font-size: 0.95rem;
    color: rgb(203, 213, 225);
    background-image: radial-gradient(rgba(148, 163, 184, 0.12) 1px, transparent 1px);
    background-size: 18px 18px;
  }

  pre {
    margin: 0;
    white-space: pre-wrap;
  }

  .typing-caret {
    display: inline-block;
    width: 2px;
    height: 1.1em;
    margin-left: 3px;
    background: var(--accent);
    animation: caret 0.9s steps(2) infinite;
    vertical-align: baseline;
  }

  .typing-caret.is-hidden {
    opacity: 0;
    animation: none;
  }

  [data-type-line] {
    position: relative;
    white-space: pre-wrap;
    min-height: 1.2em;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(30px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes gridShift {
    from {
      transform: translate3d(0, 0, 0);
    }
    to {
      transform: translate3d(-120px, -120px, 0);
    }
  }

  @keyframes matrixRain {
    0% {
      transform: translateY(-20%) rotate(-8deg);
      opacity: 0.4;
    }
    50% {
      transform: translateY(5%) rotate(-8deg);
      opacity: 0.75;
    }
    100% {
      transform: translateY(25%) rotate(-8deg);
      opacity: 0.2;
    }
  }

  @keyframes blink {
    0%,
    50% {
      opacity: 1;
    }
    50.01%,
    100% {
      opacity: 0;
    }
  }

  @keyframes caret {
    0%,
    50% {
      opacity: 1;
    }
    50.01%,
    100% {
      opacity: 0;
    }
  }
</style>

<script>
  // Efecto de escritura para elementos con data-type-line
  const typeElements = document.querySelectorAll('[data-type-line]');
  
  typeElements.forEach((element, index) => {
    const text = element.textContent?.trim() || '';
    const speed = parseInt(element.getAttribute('data-type-speed') || '50', 10);
    
    // Limpiar el elemento
    element.innerHTML = '';
    
    // Agregar cursor solo al primer y último elemento
    const shouldHaveCursor = index === typeElements.length - 1;
    
    // Escribir letra por letra
    let charIndex = 0;
    const typeInterval = setInterval(() => {
      if (charIndex <= text.length) {
        element.textContent = text.substring(0, charIndex);
        
        // Agregar cursor parpadeante
        if (shouldHaveCursor && charIndex < text.length) {
          const cursor = document.createElement('span');
          cursor.className = 'typing-caret';
          element.appendChild(cursor);
        }
        
        charIndex++;
      } else {
        clearInterval(typeInterval);
        element.textContent = text;
        
        // Marcar como listo cuando termina el último elemento
        if (shouldHaveCursor) {
          const content = element.closest('.hero-content');
          if (content) {
            content.classList.add('ready');
          }
        }
      }
    }, speed);
  });
</script>

